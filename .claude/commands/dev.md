---
description: タスク仕様に基づいて単一タスクを実装する
argument-hint: [task spec path]
---

# 実装コマンド

**タスク仕様パス:** $ARGUMENTS

---

## このコマンドの目的

`/design` コマンドで作成されたタスク仕様（spec.md）に基づいて、そのタスク単体の実装を行う。

---

## 前提条件

- タスク仕様ファイルが存在すること
- 依存タスクがすべて完了していること

---

## 事前準備

### 1. タスク仕様の読み込み

指定されたパスの `spec.md` を読み込む。

パスの指定形式:
- フルパス: `.agents/features/{feature-id}/tasks/{task-name}/spec.md`
- タスクディレクトリ: `.agents/features/{feature-id}/tasks/{task-name}/`
- 相対指定: `{feature-id}/{task-name}` → `.agents/features/{feature-id}/tasks/{task-name}/spec.md` に展開

### 2. 関連ドキュメントの参照

タスクの対象レイヤーに応じて、対応するコーディングルールを参照する:

| 対象レイヤー | 参照するルール |
|--------------|----------------|
| domain | `.claude/rules/domain.md` |
| ports | `.claude/rules/ports.md` |
| use_case | `.claude/rules/use-case.md` |
| repository | `.claude/rules/repository.md` |
| infrastructure | `.claude/rules/infrastructure.md` |
| presentation | `.claude/rules/presentation.md` |

### 3. Feature 仕様の確認

タスク仕様から Feature の `spec.md` を参照し、全体の文脈を把握する。

### 4. 依存タスクの確認

タスク仕様に記載された依存タスクがあれば、その実装状況を確認する。
依存タスクが未完了の場合は、ユーザーに報告して中断する。

---

## 実装フロー

### Phase 1: 実装計画の提示

タスク仕様に基づいて、具体的な実装計画を提示する:

1. **変更対象ファイルの確認**
   - 既存ファイルの有無を確認
   - 新規作成 or 修正の判断

2. **実装順序の決定**
   - ファイル間の依存関係を考慮
   - テストを含める場合はその順序も

3. **実装計画のサマリー**
   ```
   ## 実装計画

   ### 変更ファイル
   | ファイル | 操作 | 概要 |
   |----------|------|------|
   | ... | 新規/修正 | ... |

   ### 実装順序
   1. {ファイル名}: {何をするか}
   2. ...

   この計画で進めてよろしいですか?
   ```

### Phase 2: ユーザー承認

実装計画を提示し、ユーザーの承認を得る。

- 承認が得られたら Phase 3 へ
- 修正要望があれば計画を調整

### Phase 3: 実装

タスク仕様とスキルドキュメントに従って実装を行う。

**実装時の注意事項:**

1. **スキルドキュメントのルールに従う**
   - 各レイヤーの責務を守る
   - アンチパターンを避ける
   - ファイル配置規約に従う

2. **タスク仕様の完了条件を満たす**
   - spec.md の「完了条件」を一つずつ確認
   - すべての条件を満たすまで実装

3. **モジュール宣言の追加**
   - 新規ファイル作成時は親モジュールファイルに `pub mod xxx;` 宣言を追加
   - 例: `src/domain/models/project.rs` を作成 → `src/domain/models.rs` に `pub mod project;` を追加
   - ※ `mod.rs` は使用しない（Rust 2018 edition 以降の推奨に従う）

4. **コンパイル確認**
   - Rust コードの場合は `cargo check` で確認
   - エラーがあれば修正

5. **テストの実装と確認**
   - タスク仕様に応じたユニットテストを作成
   - `cargo test` で全テストが通ることを確認
   - テスト失敗があれば原因を特定し修正

### Phase 4: 実装完了報告

実装が完了したら、以下を報告する:

```
## 実装完了

### 変更ファイル
- {ファイル一覧}

### 完了条件の確認
- [x] {条件1}
- [x] {条件2}
- ...

### コンパイル結果
{cargo check の結果サマリー}

### テスト結果
{cargo test の結果サマリー}
- 追加したテスト: {テスト名一覧}
- 全テスト: pass / fail

### 次のタスク
{依存関係から次に実装すべきタスクがあれば提示}
```

### Phase 5: 完了レポートの出力

実装完了後、タスクディレクトリ配下に `report.md` を作成する。
このレポートは次のタスクへの引き継ぎ情報として活用される。

**出力先**: `.agents/features/{feature-id}/tasks/{task-name}/report.md`

**レポートテンプレート**:

```markdown
# Task Report: {タスク名}

> 実施日時: {YYYY-MM-DD HH:MM}
> 依存タスク: {依存タスク名（あれば）}

## 実施内容

### 変更ファイル

| ファイル | 操作 | 概要 |
|----------|------|------|
| {パス} | 新規/修正 | {概要} |

## ビルド・テスト結果

### cargo check

```
{cargo check の出力（警告含む）}
```

### cargo test（実施した場合）

```
{cargo test の出力}
```

## エビデンス

{マイグレーション結果、API レスポンス、DB クエリ結果など、
タスクの成果を示す実行結果を記載}

## 先送り事項

{現時点で解決していない警告やTODO、後続タスクで対応すべき事項}

例:
- [ ] `create_pool` 関数が未使用（09-integration で使用予定）
- [ ] エラーハンドリングの改善（別タスクで対応）

## 次タスクへの申し送り

{後続タスクの実装者が知っておくべき情報}
```

**レポート作成のポイント**:

1. **エビデンスは具体的に**: SQLの実行結果、テーブル構造、APIレスポンスなど、タスク完了を証明できる情報を記載
2. **警告は明示的に**: コンパイル警告や lint 警告は省略せずに記載し、後続タスクで解消予定かどうかを明記
3. **先送り事項は理由付き**: なぜ今対応しないのか、いつ対応予定かを記載
4. **次タスクへの配慮**: 後続タスク実装者が混乱しないよう、現状の制約や注意点を伝える

---

## エラーハンドリング

### タスク仕様が見つからない場合

```
指定されたパスにタスク仕様が見つかりませんでした: {path}

以下を確認してください:
1. パスが正しいか
2. /design コマンドでタスク仕様が作成されているか

存在する Feature 一覧:
{.agents/features/ 配下のディレクトリ一覧}
```

### 依存タスクが未完了の場合

```
このタスクには未完了の依存タスクがあります:

依存タスク: {依存タスク名}
状態: 未実装

先に依存タスクを完了させてください:
/dev {依存タスクのパス}
```

### コンパイルエラーの場合

エラー内容を分析し、修正を試みる。
3回試行しても解決しない場合は、ユーザーに報告して判断を仰ぐ。

### テスト失敗の場合

1. 失敗したテストの内容を分析
2. 実装コードまたはテストコードのどちらに問題があるか判断
3. 修正を試みる
4. 3回試行しても解決しない場合は、ユーザーに報告して判断を仰ぐ

---

## 注意事項

- **タスク仕様に忠実に**: 仕様にない変更は行わない
- **スコープを守る**: このタスクの範囲外の変更は次のタスクで行う
- **段階的に実装**: 一度に大量の変更をせず、確認しながら進める
- **Rust コード生成時**: CLAUDE.md のルールに従い、所有権・借用・トレイト等の解説を付与する
