---
description: タスク仕様に基づいて単一タスクを実装する
argument-hint: [task spec path]
---

# 実装コマンド

**タスク仕様パス:** $ARGUMENTS

---

## このコマンドの目的

`/design` コマンドで作成されたタスク仕様（spec.md）に基づいて、そのタスク単体の実装を行う。

---

## 前提条件

- タスク仕様ファイルが存在すること
- 依存タスクがすべて完了していること

---

## 事前準備

### 1. タスク仕様の読み込み

指定されたパスの `spec.md` を読み込む。

パスの指定形式:
- フルパス: `.agents/features/{feature-id}/tasks/{task-name}/spec.md`
- タスクディレクトリ: `.agents/features/{feature-id}/tasks/{task-name}/`
- 相対指定: `{feature-id}/{task-name}` → `.agents/features/{feature-id}/tasks/{task-name}/spec.md` に展開

### 2. 関連ドキュメントの参照

タスクの対象レイヤーに応じて、対応するコーディングルールを参照する:

| 対象レイヤー | 参照するルール |
|--------------|----------------|
| domain | `.claude/rules/domain.md` |
| ports | `.claude/rules/ports.md` |
| use_case | `.claude/rules/use-case.md` |
| repository | `.claude/rules/repository.md` |
| infrastructure | `.claude/rules/infrastructure.md` |
| presentation | `.claude/rules/presentation.md` |

### 3. Feature 仕様の確認

タスク仕様から Feature の `spec.md` を参照し、全体の文脈を把握する。

### 4. 依存タスクの確認

タスク仕様に記載された依存タスクがあれば、その実装状況を確認する。
依存タスクが未完了の場合は、ユーザーに報告して中断する。

---

## 実装フロー

### Phase 1: 実装計画の提示

タスク仕様に基づいて、具体的な実装計画を提示する:

1. **変更対象ファイルの確認**
   - 既存ファイルの有無を確認
   - 新規作成 or 修正の判断

2. **実装順序の決定**
   - ファイル間の依存関係を考慮
   - テストを含める場合はその順序も

3. **実装計画のサマリー**
   ```
   ## 実装計画

   ### 変更ファイル
   | ファイル | 操作 | 概要 |
   |----------|------|------|
   | ... | 新規/修正 | ... |

   ### 実装順序
   1. {ファイル名}: {何をするか}
   2. ...

   この計画で進めてよろしいですか?
   ```

### Phase 2: ユーザー承認

実装計画を提示し、ユーザーの承認を得る。

- 承認が得られたら Phase 3 へ
- 修正要望があれば計画を調整

### Phase 3: 実装

タスク仕様とスキルドキュメントに従って実装を行う。

**実装時の注意事項:**

1. **スキルドキュメントのルールに従う**
   - 各レイヤーの責務を守る
   - アンチパターンを避ける
   - ファイル配置規約に従う

2. **タスク仕様の完了条件を満たす**
   - spec.md の「完了条件」を一つずつ確認
   - すべての条件を満たすまで実装

3. **モジュール宣言の追加**
   - 新規ファイル作成時は親モジュールファイルに `pub mod xxx;` 宣言を追加
   - 例: `src/domain/models/project.rs` を作成 → `src/domain/models.rs` に `pub mod project;` を追加
   - ※ `mod.rs` は使用しない（Rust 2018 edition 以降の推奨に従う）

4. **コンパイル確認**
   - Rust コードの場合は `cargo check` で確認
   - エラーがあれば修正

5. **テストの実装と確認**
   - タスク仕様に応じたユニットテストを作成
   - `cargo test` で全テストが通ることを確認
   - テスト失敗があれば原因を特定し修正

### Phase 4: 実装完了報告・レビュー依頼

実装が完了したら、以下を報告しレビューを依頼する:

```
## 実装完了

### 変更ファイル
- {ファイル一覧}

### 完了条件の確認
- [x] {条件1}
- [x] {条件2}
- ...

### コンパイル結果
{cargo check の結果サマリー}

### テスト結果
{cargo test の結果サマリー}
- 追加したテスト: {テスト名一覧}
- 全テスト: pass / fail

---

上記の内容をご確認ください。問題なければ承認をお願いします。
修正が必要な場合はご指摘ください。
```

**レビュー対応**:

- 修正指摘があれば対応する
- 再度レビュー依頼を行う
- 承認が得られたら Phase 5 へ

### Phase 5: 完了レポートの出力

レビュー承認後、タスクディレクトリ配下に `report.md` を作成する。
このレポートは次のタスクへの引き継ぎ情報として活用される。

**出力先**: `.agents/features/{feature-id}/tasks/{task-name}/report.md`

**レポートテンプレート**:

```markdown
# Task Report: {タスク名}

> 実施日時: {YYYY-MM-DD}
> 依存タスク: {依存タスク名（あれば）}

## 実施内容

### 変更ファイル

| ファイル | 操作 | 概要 |
|----------|------|------|
| {パス} | 新規/修正 | {概要} |

## ビルド・テスト結果

### cargo check

```
{cargo check の出力（警告含む）}
```

### cargo test

```
{cargo test の出力}
```

## 設計上の議論と決定

{レビューで議論・検討が発生した場合のみ記載}

### {議論のテーマ}

**議論**:
- {何が問題・論点だったか}

**検討した選択肢**:

1. **{選択肢1}（採用 or 不採用）**
   - {概要}
   - {メリット/デメリット}

2. **{選択肢2}（採用 or 不採用）**
   - {概要}
   - {メリット/デメリット}

**決定理由**:
- {なぜその選択肢を採用したか}

## 先送り事項

{現時点で解決していない警告やTODO、後続タスクで対応すべき事項}

例:
- [ ] `create_pool` 関数が未使用（09-integration で使用予定）
- [ ] エラーハンドリングの改善（別タスクで対応）

## 次タスクへの申し送り

{後続タスクの実装者が知っておくべき情報}
```

**レポート作成のポイント**:

1. **設計上の議論は選択肢を残す**: 完成コードからは読み取れない「採用しなかった選択肢」を記録し、将来の振り返りに活用
2. **警告は明示的に**: コンパイル警告や lint 警告は省略せずに記載し、後続タスクで解消予定かどうかを明記
3. **先送り事項は理由付き**: なぜ今対応しないのか、いつ対応予定かを記載
4. **次タスクへの配慮**: 後続タスク実装者が混乱しないよう、現状の制約や注意点を伝える

### Phase 6: 後続タスクの見直し

今回の実装で設計変更があった場合、後続タスクの spec.md を見直す。

**見直し手順**:

1. Feature の spec.md からタスク一覧を確認
2. 今回のタスクに依存する後続タスクを特定
3. 各後続タスクの spec.md を読み、今回の変更で影響を受ける箇所を確認
4. 必要に応じて spec.md を修正

**見直し観点**:

- 今回追加・変更したメソッド名や型名が後続タスクで参照されているか
- 設計変更により後続タスクの実装方針が変わるか
- 後続タスクの前提条件が変わっていないか

**見直し結果の報告**:

```
## 後続タスク見直し結果

### 影響を受けるタスク

| タスク | 修正箇所 | 修正内容 |
|--------|----------|----------|
| {タスク名} | {ファイル:行} | {何を修正したか} |

### 影響なしのタスク

| タスク | 理由 |
|--------|------|
| {タスク名} | {影響がない理由} |
```

### Phase 7: Git コミット

後続タスク見直し完了後、変更内容を Git コミットする。

**コミット手順**:

1. `git status` で変更ファイルを確認
2. `git add` で変更をステージング
3. 以下の形式でコミットメッセージを作成してコミット

**コミットメッセージ形式**:

```
feat({feature-id}): {タスク名}

- {変更内容1}
- {変更内容2}
- ...

Task: {task-name}
```

**例**:

```
feat(get-minimum-project): DBマイグレーション（projects テーブル）

- projects テーブル作成マイグレーション追加
- sqlx-cli を Dockerfile に追加
- サンプルデータ投入用 SQL 作成

Task: 03-migration
```

**コミット後の報告**:

```
## コミット完了

コミットハッシュ: {hash}
ブランチ: {branch}

次のタスク:
- {次に実装可能なタスク一覧}
```

---

## エラーハンドリング

### タスク仕様が見つからない場合

```
指定されたパスにタスク仕様が見つかりませんでした: {path}

以下を確認してください:
1. パスが正しいか
2. /design コマンドでタスク仕様が作成されているか

存在する Feature 一覧:
{.agents/features/ 配下のディレクトリ一覧}
```

### 依存タスクが未完了の場合

```
このタスクには未完了の依存タスクがあります:

依存タスク: {依存タスク名}
状態: 未実装

先に依存タスクを完了させてください:
/dev {依存タスクのパス}
```

### コンパイルエラーの場合

エラー内容を分析し、修正を試みる。
3回試行しても解決しない場合は、ユーザーに報告して判断を仰ぐ。

### テスト失敗の場合

1. 失敗したテストの内容を分析
2. 実装コードまたはテストコードのどちらに問題があるか判断
3. 修正を試みる
4. 3回試行しても解決しない場合は、ユーザーに報告して判断を仰ぐ

---

## 注意事項

- **タスク仕様に忠実に**: 仕様にない変更は行わない
- **スコープを守る**: このタスクの範囲外の変更は次のタスクで行う
- **段階的に実装**: 一度に大量の変更をせず、確認しながら進める
